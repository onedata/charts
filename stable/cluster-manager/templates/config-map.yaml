apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ template "fullname" . }}-config
  labels:
    app: {{ template "fullname" . }}
    chart: {{ .Chart.Name }}
    release: {{ template "releaseName" .  }}
    heritage: {{ .Release.Service }}
    component: "cluster-manager"
  annotations:
    version: "{{ .Chart.Version }}"
data:
  CLUSTER-MANAGER_CONFIG: |-
    cluster-manager:
      domain: "{{ template "service_url" . }}"
  vm.args.template: |-
    ## Name of the node
    -name cluster_manager@${HOSTNAME}

    ## Cookie for distributed erlang
    -setcookie cluster_node

    ## Treat lager warnings as warnings
    +W w

    ## Increase number of concurrent ports/sockets
    ## Warning: too high growth of this param consumes a lot of memory
    -env ERL_MAX_PORTS 1000000

    ## Increase number of processes
    +P 1000000

    ## Set the location of crash dumps
    -env ERL_CRASH_DUMP ./log/erl_crash.dump

    ## Upgrade ets limit (tmp ets are used for transactions)
    -env ERL_MAX_ETS_TABLES 1000000

    ## Configure schedulers
    ## +S 32:32
    ## +SDcpu 16:8
    +K true
    ## +sfwi 500
    +stbt db
    +sbwt none
    ## +scl false
    ## +sub true

    ## Enable Symmetric Multiprocessing
    -smp enable

    ## Set default heap size (256 MB with 8byte word)
    ## +hmax 33554432  
  app.config.template: |-
    [
      % NOTE: this is needed to deploy oneprovider on distributed env on dockers
      % Range of ports that will be used by erlang nodes to communicate
      {kernel,[
          {inet_dist_listen_min, 9100},
          {inet_dist_listen_max, 9139}
      ]},

      %% SASL config
      {sasl, [{sasl_error_logger, false}]},

      %% logger configuration
      {lager, [
          {colored, true},
          {log_root, "./log"},
          {handlers, [
              %% show info level or higher level logs at console
              {lager_console_backend, [
                  {level, info}, {formatter, lager_default_formatter},
                  {formatter_config, [color, "[", sev, " ", time, " ", pid, "] ", message, "\e[0m\r\n"]}
              ]},
              %% rotate error log when it reaches 50 MB; keep 10 rotated logs
              {lager_file_backend, [
                  {file, "error.log"},
                  {level, error},
                  {size, 52428800},
                  {count, 10},
                  {formatter, lager_default_formatter},
                  {formatter_config, ["[", sev, " ", date, " ", time, " ", pid, "] ", message, "\n"]}
              ]},
              %% rotate info log when it reaches 50 MB; keep 10 rotated logs
              {lager_file_backend, [
                  {file, "info.log"},
                  {level, info},
                  {size, 52428800},
                  {count, 10},
                  {formatter, lager_default_formatter},
                  {formatter_config, ["[", sev, " ", date, " ", time, " ", pid, "] ", message, "\n"]}
              ]},
              %% rotate debug log when it reaches 50 MB; keep 10 rotated logs
              {lager_file_backend, [
                  {file, "debug.log"},
                  {level, debug},
                  {size, 52428800},
                  {count, 10},
                  {formatter, lager_default_formatter},
                  {formatter_config, ["[", sev, " ", date, " ", time, " ", pid, "] ", message, "\n"]}
              ]}
          ]},
          % Limit for the number of messages per second allowed from error_logger
          {error_logger_hwm, 200},
          % When lager should change mode to synchronous (log queue is longer than async_threshold)
          {async_threshold, 500},
          % When lager should return from synchronous mode to asynchronous (log queue is shorter than (async_threshold - async_threshold_window)
          {async_threshold_window, 50}
      ]},

      {ctool, [
          % Backup file that stores the information needed to restore the
          % previous clock synchronization.
          {clock_sync_backup_file, "./etc/time_synchronization_data.json"}
      ]},

      %% cluster_manager config
      {cluster_manager, [
          %% ===================================================================
          %% GENERAL
          %% ===================================================================

          %% How many worker nodes are expected to connect to cm - configured automatically by configurator.erl lib, used in GEN_DEV script
          {worker_num, {{ .Values.worker_num }} },
          % How often should load balancing advices be recomputed and sent to nodes [ms].
          {lb_advices_update_interval, 500},

          %% ===================================================================
          %% CLUSTER INIT STEPS
          %% ===================================================================

          {init_connection_step_timeout, 300000}, % 5 minutes
          {start_default_workers_step_timeout, 600000}, % 10 minutes
          {prepare_for_upgrade_step_timeout, 120000}, % 2 minutes
          {upgrade_cluster_step_timeout, 3600000}, % 1 hour
          {start_custom_workers_step_timeout, 300000}, % 5 minutes
          {db_and_workers_ready_step_timeout, 300000}, % 5 minutes
          {start_listeners_step_timeout, 120000}, % 2 minutes
          {cluster_ready_step_timeout, 120000}, % 2 minutes

          %% ===================================================================
          %% CLUSTER STATUS
          %% ===================================================================

          {cluster_status_caching_time_seconds, 15},
          {cluster_component_healthcheck_timeout, 10000} % 10 seconds
      ]}
    ].
